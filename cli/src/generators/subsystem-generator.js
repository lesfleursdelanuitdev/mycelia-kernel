/**
 * Subsystem Generator
 * Generates subsystem files
 */

import { existsSync, mkdirSync, writeFileSync } from 'fs';
import { join } from 'path';
import { toKebabCase, toPascalCase } from '../utils/file-utils.js';

export async function generateSubsystem(name, options = {}) {
  const cwd = process.cwd();
  const kebabName = toKebabCase(name);
  const pascalName = toPascalCase(name);
  const subsystemDir = join(cwd, 'src', 'subsystems', kebabName);

  console.log(`Generating subsystem: ${pascalName}Subsystem`);

  // Create directory
  if (!existsSync(subsystemDir)) {
    mkdirSync(subsystemDir, { recursive: true });
  }

  // Generate subsystem file
  const subsystemContent = generateSubsystemFile(pascalName, kebabName, options);
  writeFileSync(join(subsystemDir, `${kebabName}.subsystem.mycelia.js`), subsystemContent);

  // Generate routes definition file
  const routesContent = generateRoutesDefinitionFile(pascalName, kebabName);
  writeFileSync(join(subsystemDir, `${kebabName}.routes.def.mycelia.js`), routesContent);

  // Generate commands definition file
  const commandsContent = generateCommandsDefinitionFile(pascalName, kebabName);
  writeFileSync(join(subsystemDir, `${kebabName}.commands.def.mycelia.js`), commandsContent);

  // Generate queries definition file
  const queriesContent = generateQueriesDefinitionFile(pascalName, kebabName);
  writeFileSync(join(subsystemDir, `${kebabName}.queries.def.mycelia.js`), queriesContent);

  console.log(`âœ… Subsystem generated: ${subsystemDir}`);
}

function generateSubsystemFile(pascalName, kebabName, options = {}) {
  const constantName = pascalName.toUpperCase().replace(/-/g, '_');
  
  // Determine which default hooks to use
  let defaultHooksImport = '';
  let defaultHooksCode = '';
  
  if (options.useDefaultsAsync) {
    defaultHooksImport = `import { createCanonicalDefaultHooks } from '../../mycelia-kernel-v2/index.js';`;
    defaultHooksCode = `
    // Use canonical (asynchronous) default hooks
    this.defaultHooks = createCanonicalDefaultHooks();`;
  } else if (options.useDefaultsSync) {
    defaultHooksImport = `import { createSynchronousDefaultHooks } from '../../mycelia-kernel-v2/index.js';`;
    defaultHooksCode = `
    // Use synchronous default hooks (for kernel-like subsystems)
    this.defaultHooks = createSynchronousDefaultHooks();`;
  } else {
    // No default hooks - keep placeholder comments
    defaultHooksCode = `
    // Register hooks
    // this.use(useRouter);
    // this.use(useQueue);`;
  }
  
  const imports = [
    `import { BaseSubsystem } from '../../mycelia-kernel-v2/index.js';`,
    defaultHooksImport,
    `import { ${constantName}_ROUTES } from './${kebabName}.routes.def.mycelia.js';`,
    `import { ${constantName}_COMMANDS } from './${kebabName}.commands.def.mycelia.js';`,
    `import { ${constantName}_QUERIES } from './${kebabName}.queries.def.mycelia.js';`
  ].filter(Boolean).join('\n');
  
  return `/**
 * ${pascalName}Subsystem
 * Generated by mycelia-kernel CLI
 */

${imports}

export class ${pascalName}Subsystem extends BaseSubsystem {
  constructor(name, options = {}) {
    super(name, options);${defaultHooksCode}
  }

  async onInit() {
    // Register routes using the definitions in a loop
    const router = this.find('router');
    if (router) {
      for (const [routeName, routeDef] of Object.entries(${constantName}_ROUTES)) {
        const handlerMethod = this[routeDef.handler];
        
        if (!handlerMethod) {
          console.warn(\`${pascalName}Subsystem: Handler "\${routeDef.handler}" not found for route "\${routeName}"\`);
          continue;
        }
        
        router.registerRoute(
          routeDef.path,
          handlerMethod.bind(this),
          routeDef.metadata
        );
      }
    }
    
    // Register commands using the definitions in a loop
    const commands = this.find('commands');
    const channels = this.find('channels');
    if (commands && channels) {
      for (const [cmdName, cmdDef] of Object.entries(${constantName}_COMMANDS)) {
        const handlerMethod = this[cmdDef.handler];
        
        if (!handlerMethod) {
          console.warn(\`${pascalName}Subsystem: Handler "\${cmdDef.handler}" not found for command "\${cmdName}"\`);
          continue;
        }
        
        let channelRoute = null;
        
        // Create channel if needed
        if (cmdDef.createChannel && cmdDef.channel) {
          const channel = channels.create(cmdDef.channel, cmdDef.channelOptions || {});
          channelRoute = channel.route;  // e.g., 'subsystem://channel/channel-name'
        } else if (cmdDef.replyChannel) {
          channelRoute = cmdDef.replyChannel;
        }
        
        // Register command
        commands.register(cmdName, {
          path: cmdDef.path,
          replyChannel: channelRoute,
          timeout: cmdDef.timeout,
          meta: cmdDef.metadata || {}
        });
        
        // Register command handler route
        if (router) {
          router.registerRoute(
            cmdDef.path,
            handlerMethod.bind(this),
            cmdDef.metadata
          );
        }
        
        // Register reply channel handler
        if (channelRoute && router) {
          router.registerRoute(channelRoute, (responseMessage) => {
            const requests = this.find('requests');
            if (requests && requests.commandManager) {
              requests.commandManager.handleCommandReply(responseMessage);
            }
          });
        }
      }
    }
    
    // Register queries using the definitions in a loop
    const queries = this.find('queries');
    if (queries) {
      for (const [queryName, queryDef] of Object.entries(${constantName}_QUERIES)) {
        const handlerMethod = this[queryDef.handler];
        
        if (!handlerMethod) {
          console.warn(\`${pascalName}Subsystem: Handler "\${queryDef.handler}" not found for query "\${queryName}"\`);
          continue;
        }
        
        // Use name-based registration if name is provided, otherwise use path
        if (queryDef.name) {
          queries.register(queryDef.name, handlerMethod.bind(this), queryDef.metadata || {});
        } else if (queryDef.path) {
          queries.registerRoute(queryDef.path, handlerMethod.bind(this), queryDef.metadata || {});
        } else {
          // Default: use query key as name
          queries.register(queryName, handlerMethod.bind(this), queryDef.metadata || {});
        }
      }
    }
  }

  // Route handlers
  // TODO: Implement handlers matching route definitions
}
`;
}

function generateRoutesDefinitionFile(pascalName, kebabName) {
  const constantName = pascalName.toUpperCase().replace(/-/g, '_');
  
  return `/**
 * Route definitions for ${pascalName}Subsystem
 * Generated by mycelia-kernel CLI
 */

export const ${constantName}_ROUTES = {
  // Example route - update with your actual routes
  'exampleRoute': {
    path: '${kebabName}://operation/example',
    description: 'Example route description',
    handler: 'handleExample',
    metadata: {
      method: 'GET',
      required: 'read'
    }
  }
};
`;
}

function generateCommandsDefinitionFile(pascalName, kebabName) {
  const constantName = pascalName.toUpperCase().replace(/-/g, '_');
  
  return `/**
 * Command definitions for ${pascalName}Subsystem
 * Generated by mycelia-kernel CLI
 */

export const ${constantName}_COMMANDS = {
  // Example command - update with your actual commands
  'exampleCommand': {
    path: '${kebabName}://operation/command',
    description: 'Example command description',
    handler: 'handleExampleCommand',
    channel: 'example-replies',              // Channel name (local, will be: subsystem://channel/example-replies)
    createChannel: true,                     // Auto-create channel
    channelOptions: {
      participants: [],
      metadata: { description: 'Example command replies' }
    },
    timeout: 10000,
    metadata: {
      method: 'POST',
      required: 'write'
    }
  }
};
`;
}

function generateQueriesDefinitionFile(pascalName, kebabName) {
  const constantName = pascalName.toUpperCase().replace(/-/g, '_');
  
  return `/**
 * Query definitions for ${pascalName}Subsystem
 * Generated by mycelia-kernel CLI
 */

export const ${constantName}_QUERIES = {
  // Example query - update with your actual queries
  'exampleQuery': {
    name: 'exampleQuery',                    // Query name (optional, defaults to key)
    path: '${kebabName}://query/example',    // Full path (optional, auto-generated if not provided)
    description: 'Example query description',
    handler: 'handleExampleQuery',           // Method name on subsystem
    metadata: {
      method: 'GET',
      required: 'read'
    }
  }
};
`;
}


